#!/bin/bash

set -e

VERSION="v0.9.0"
DOTFILES="$HOME/.config/dots"
TRASH="$HOME/.local/share/Trash/files"





# ====[ COMMANDS ]=============================================================





# Snatch a single config (internal helper)
snatch_single() {
    local raw_config_name="$1"

    # Find in filesystem
    local result=$(find_in_filesystem "$raw_config_name")
    [[ "$result" == "none" ]] && error "Config '$raw_config_name' not found in .config or home"

    local type found_name
    read type found_name <<< "$result"
    local source_path

    if [[ "$type" == "config" ]]; then
        source_path="$HOME/.config/$found_name"
    else
        source_path="$HOME/$found_name"
    fi

    # Check if it's a symlink
    [[ -L "$source_path" ]] && error "Cannot snatch symlinks - '$source_path' is already a symlink"

    # Check if already exists in dotfiles
    local dots_location=$(find_in_dotfiles "$raw_config_name")
    [[ "$dots_location" != "none" ]] && error "'$raw_config_name' already exists in dots repo"

    # Determine destination in dotfiles
    local dest_path="$DOTFILES/$type/$found_name"

    # Move to dotfiles
    mv "$source_path" "$dest_path"

    # Create symlink
    ln -s "$dest_path" "$source_path"

    # Auto-commit
    cd "$DOTFILES"
    git add "$dest_path" >/dev/null 2>&1
    git commit -m "snatch: add $found_name" >/dev/null 2>&1

    info "snatched $found_name"
}

cmd_snatch() {
    [[ -z "$1" ]] && error "Usage: dots snatch <config-name> [<config-name>...]"

    check_dotfiles_repo
    ensure_dotfiles_structure

    # Batch mode: snatch multiple configs
    for name in "$@"; do
        snatch_single "$name"
    done
}

# Link a single config (internal helper)
link_single() {
    local name="$1"

    # Find in dotfiles repo
    local result=$(find_in_dotfiles "$name")
    [[ "$result" == "none" ]] && error "'$name' not found in dots repo"

    local type found_name
    read type found_name <<< "$result"
    local dots_path="$DOTFILES/$type/$found_name"

    # Determine target path
    local target_path
    if [[ "$type" == "config" ]]; then
        target_path="$HOME/.config/$found_name"
    else
        target_path="$HOME/$found_name"
    fi

    # Check if target exists
    if [[ -e "$target_path" ]] || [[ -L "$target_path" ]]; then
        if [[ -L "$target_path" ]]; then
            # It's a symlink, remove and replace
            info "Replacing existing symlink at $target_path"
            rm "$target_path"
        else
            # It's a real file/folder - give detailed error
            local type="file"
            [[ -d "$target_path" ]] && type="directory"
            error "Target '$target_path' already exists as a $type\nUse 'dots rm $name' to move it to trash first, or 'dots snatch $name' to adopt it"
        fi
    fi

    # Create parent directory if needed
    mkdir -p "$(dirname "$target_path")"

    # Create symlink
    ln -s "$dots_path" "$target_path"

    success "Linked $found_name"
}

cmd_link() {
    check_dotfiles_repo

    # Handle -A / --all flag
    if [[ "$1" == "-A" ]] || [[ "$1" == "--all" ]]; then
        info "Linking all configs from dots repo..."
        local linked=0
        local skipped=0

        # Link all configs
        for config_path in "$DOTFILES/config"/*; do
            [[ -e "$config_path" ]] || continue
            local name=$(basename "$config_path")
            local target="$HOME/.config/$name"

            # Check if already correctly linked
            if [[ -L "$target" ]] && [[ "$(readlink "$target")" == "$config_path" ]]; then
                ((skipped++)) || true
                continue
            fi

            # Check if target exists (and is not a symlink we can replace)
            if [[ -e "$target" ]] || [[ -L "$target" ]]; then
                if [[ -L "$target" ]]; then
                    # Broken symlink or wrong symlink - replace it
                    rm "$target"
                    mkdir -p "$(dirname "$target")"
                    ln -s "$config_path" "$target"
                    echo "  Linked $name"
                    ((linked++)) || true
                else
                    # Real file/directory - skip with warning
                    warn "Skipped $name (real file/directory exists)"
                    ((skipped++)) || true
                fi
            else
                # Doesn't exist - create symlink
                mkdir -p "$(dirname "$target")"
                ln -s "$config_path" "$target"
                echo "  Linked $name"
                ((linked++)) || true
            fi
        done

        # Link all home files
        for home_path in "$DOTFILES/home"/*; do
            [[ -e "$home_path" ]] || continue
            local name=$(basename "$home_path")
            local target="$HOME/$name"

            # Check if already correctly linked
            if [[ -L "$target" ]] && [[ "$(readlink "$target")" == "$home_path" ]]; then
                ((skipped++)) || true
                continue
            fi

            # Check if target exists (and is not a symlink we can replace)
            if [[ -e "$target" ]] || [[ -L "$target" ]]; then
                if [[ -L "$target" ]]; then
                    # Broken symlink or wrong symlink - replace it
                    rm "$target"
                    mkdir -p "$(dirname "$target")"
                    ln -s "$home_path" "$target"
                    echo "  Linked $name"
                    ((linked++)) || true
                else
                    # Real file/directory - skip with warning
                    warn "Skipped $name (real file/directory exists)"
                    ((skipped++)) || true
                fi
            else
                # Doesn't exist - create symlink
                mkdir -p "$(dirname "$target")"
                ln -s "$home_path" "$target"
                echo "  Linked $name"
                ((linked++)) || true
            fi
        done

        success "Linked $linked configs ($skipped already linked or skipped)"
        return
    fi

    # No arguments provided
    [[ -z "$1" ]] && error "Usage: dots link <config-name> [<config-name>...]\n       dots link -A|--all"

    # Batch mode: link multiple configs
    for name in "$@"; do
        link_single "$name"
    done
}

# Remove a single config (internal helper)
rm_single() {
    local name="$1"

    # Find in filesystem
    local result=$(find_in_filesystem "$name")
    [[ "$result" == "none" ]] && error "Config '$name' not found in ~/.config or ~/"

    local type found_name
    read type found_name <<< "$result"
    local target_path

    if [[ "$type" == "config" ]]; then
        target_path="$HOME/.config/$found_name"
    else
        target_path="$HOME/$found_name"
    fi

    # If it's a symlink, just remove it (no trash needed)
    if [[ -L "$target_path" ]]; then
        rm "$target_path"
        success "Removed symlink $found_name"
        return
    fi

    # It's a real file/folder - move to trash for safety
    mkdir -p "$TRASH"

    # Generate unique trash name if needed
    local trash_path="$TRASH/$found_name"
    if [[ -e "$trash_path" ]]; then
        trash_path="$TRASH/${found_name}.$(date +%s)"
    fi

    info "Moving $target_path → $trash_path"
    mv "$target_path" "$trash_path"

    success "Moved $found_name to trash"
}

cmd_rm() {
    [[ -z "$1" ]] && error "Usage: dots rm <config-name> [<config-name>...]"

    # Batch mode: remove multiple configs
    for name in "$@"; do
        rm_single "$name"
    done
}

# Eject a single config (internal helper)
eject_single() {
    local name="$1"

    # Find in dotfiles repo
    local result=$(find_in_dotfiles "$name")
    [[ "$result" == "none" ]] && error "'$name' not found in dots repo"

    local type found_name
    read type found_name <<< "$result"
    local dots_path="$DOTFILES/$type/$found_name"

    # Determine target path
    local target_path
    if [[ "$type" == "config" ]]; then
        target_path="$HOME/.config/$found_name"
    else
        target_path="$HOME/$found_name"
    fi

    # If symlink exists pointing to dots, remove it
    if [[ -L "$target_path" ]]; then
        local link_target=$(readlink "$target_path")
        if [[ "$link_target" == "$dots_path" ]]; then
            rm "$target_path"
        else
            warn "Symlink exists but doesn't point to dots - leaving it alone"
        fi
    fi

    # Check if target already has a real file/dir (conflict)
    if [[ -e "$target_path" ]]; then
        local file_type="file"
        [[ -d "$target_path" ]] && file_type="directory"
        error "Target '$target_path' already exists as a $file_type\nCannot eject - conflict at destination"
    fi

    # Create parent directory if needed
    mkdir -p "$(dirname "$target_path")"

    # Move from dots to target location
    mv "$dots_path" "$target_path"

    # Remove from git and commit
    cd "$DOTFILES"
    git rm -r "$type/$found_name" >/dev/null 2>&1
    git commit -m "eject: remove $found_name" >/dev/null 2>&1

    echo -e "${PURPLE}→ ejected $found_name${NC}"
}

cmd_eject() {
    [[ -z "$1" ]] && error "Usage: dots eject <config-name> [<config-name>...]"

    check_dotfiles_repo

    # Batch mode: eject multiple configs
    for name in "$@"; do
        eject_single "$name"
    done
}

# Unlink a single config (internal helper)
unlink_single() {
    local name="$1"

    # Find in filesystem
    local result=$(find_in_filesystem "$name")
    [[ "$result" == "none" ]] && error "'$name' not found in ~/.config or ~/"

    local type found_name
    read type found_name <<< "$result"
    local target_path

    if [[ "$type" == "config" ]]; then
        target_path="$HOME/.config/$found_name"
    else
        target_path="$HOME/$found_name"
    fi

    # Check if it exists
    [[ ! -e "$target_path" ]] && [[ ! -L "$target_path" ]] && error "'$found_name' not found"

    # Check if it's a symlink
    [[ ! -L "$target_path" ]] && error "'$found_name' is not a symlink (it's a real file/directory)\nUse 'dots rm $name' to move it to trash"

    # Check if it points to dots repo
    local link_target=$(readlink "$target_path")
    if [[ "$link_target" != "$DOTFILES/"* ]]; then
        error "'$found_name' doesn't point to dots repo\nPoints to: $link_target"
    fi

    # Safe to remove
    rm "$target_path"
    echo -e "${PURPLE}→ Unlinked $found_name${NC}"
}

cmd_unlink() {
    check_dotfiles_repo

    # Handle -A / --all flag
    if [[ "$1" == "-A" ]] || [[ "$1" == "--all" ]]; then
        info "Unlinking all configs from dots repo..."
        local unlinked=0
        local skipped=0

        # Check all configs
        for config_path in "$DOTFILES/config"/*; do
            [[ -e "$config_path" ]] || continue
            local name=$(basename "$config_path")
            local target="$HOME/.config/$name"

            # Unlink if it's a symlink pointing to dots or if it's broken
            if [[ -L "$target" ]]; then
                if [[ "$(readlink "$target")" == "$config_path" ]]; then
                    # Points to dots - remove it
                    rm "$target"
                    echo -e "${PURPLE}  → Unlinked $name${NC}"
                    ((unlinked++)) || true
                elif [[ ! -e "$target" ]]; then
                    # Broken symlink - remove it
                    rm "$target"
                    echo -e "${PURPLE}  → Unlinked $name (broken)${NC}"
                    ((unlinked++)) || true
                else
                    # Symlink pointing elsewhere - skip
                    ((skipped++)) || true
                fi
            else
                ((skipped++)) || true
            fi
        done

        # Check all home files
        for home_path in "$DOTFILES/home"/*; do
            [[ -e "$home_path" ]] || continue
            local name=$(basename "$home_path")
            local target="$HOME/$name"

            # Unlink if it's a symlink pointing to dots or if it's broken
            if [[ -L "$target" ]]; then
                if [[ "$(readlink "$target")" == "$home_path" ]]; then
                    # Points to dots - remove it
                    rm "$target"
                    echo -e "${PURPLE}  → Unlinked $name${NC}"
                    ((unlinked++)) || true
                elif [[ ! -e "$target" ]]; then
                    # Broken symlink - remove it
                    rm "$target"
                    echo -e "${PURPLE}  → Unlinked $name (broken)${NC}"
                    ((unlinked++)) || true
                else
                    # Symlink pointing elsewhere - skip
                    ((skipped++)) || true
                fi
            else
                ((skipped++)) || true
            fi
        done

        echo -e "${PURPLE}→ Unlinked $unlinked configs ($skipped not linked or not symlinks)${NC}"
        return
    fi

    # No arguments provided
    [[ -z "$1" ]] && error "Usage: dots unlink <config-name> [<config-name>...]\n       dots unlink -A|--all"

    # Batch mode: unlink multiple configs
    for name in "$@"; do
        unlink_single "$name"
    done
}

cmd_sync() {
    check_dotfiles_repo

    cd "$DOTFILES"

    # Check if remote is configured
    if ! git remote get-url origin >/dev/null 2>&1; then
        error "No remote configured.\nRun: dots setup <username/repo>"
    fi

    git pull

    # Check for unpushed commits
    if git rev-parse @{u} >/dev/null 2>&1; then
        local unpushed=$(git rev-list @{u}..HEAD --count 2>/dev/null || echo "0")
        if [[ "$unpushed" -gt 0 ]]; then
            warn "You have $unpushed unpushed commit(s). Run 'dots push' to push them."
        fi
    fi

    # Silent check for dots tool updates
    notify_if_updates
}

cmd_push() {
    check_dotfiles_repo

    cd "$DOTFILES"

    # Check if remote is configured
    if ! git remote get-url origin >/dev/null 2>&1; then
        error "No remote configured.\nRun: dots setup <username/repo>"
    fi

    git push

    # Silent check for dots tool updates
    notify_if_updates
}

cmd_detach() {
    check_dotfiles_repo
    cd "$DOTFILES"

    # Check if remote exists
    if ! git remote get-url origin >/dev/null 2>&1; then
        error "No remote configured. Nothing to detach."
    fi

    local current_remote=$(git remote get-url origin)
    warn "This will detach from: $current_remote"
    echo -n "Continue? (y/N): "
    read -r choice

    case "${choice,,}" in
        y|yes)
            git remote remove origin
            success "Detached from GitHub. Your local dotfiles remain intact."
            ;;
        *)
            info "Cancelled."
            ;;
    esac
}

cmd_setup() {
    local repo_arg="$1"
    [[ -z "$repo_arg" ]] && error "Usage: dots setup <username/repo>"

    check_dotfiles_repo
    cd "$DOTFILES"

    # Check if remote already exists
    if git remote get-url origin >/dev/null 2>&1; then
        local current_remote=$(git remote get-url origin)
        warn "Remote already configured: $current_remote"
        echo -n "Switch to $repo_arg? (y/N): "
        read -r choice

        case "${choice,,}" in
            y|yes)
                git remote remove origin
                info "Removed old remote"
                ;;
            *)
                info "Cancelled. Use 'dots detach' to remove remote without reconnecting."
                exit 0
                ;;
        esac
    fi

    # Smart URL selection based on authentication method
    local git_url

    # Priority 1: gh CLI (best UX)
    if command -v gh >/dev/null 2>&1 && gh auth status >/dev/null 2>&1; then
        git_url="https://github.com/${repo_arg}.git"
        info "Using HTTPS (gh CLI detected)"

    # Priority 2: SSH keys exist
    elif [[ -f ~/.ssh/id_rsa ]] || [[ -f ~/.ssh/id_ed25519 ]] || [[ -f ~/.ssh/id_ecdsa ]]; then
        git_url="git@github.com:${repo_arg}.git"
        info "Using SSH (keys detected - ensure they're added to GitHub)"

    # Priority 3: Nothing configured - offer auto-install
    else
        warn "No GitHub authentication configured"
        echo ""
        echo "Quick setup: Install gh CLI via webi.sh (cross-platform, no sudo)"
        echo ""
        echo -n "Auto-install and authenticate now? (Y/n): "
        read -r choice

        case "${choice,,}" in
            n|no)
                echo ""
                info "To install manually, run:"
                echo "  curl -sS https://webi.sh/gh | sh"
                echo "  gh auth login"
                echo ""
                info "Or visit: https://cli.github.com"
                info "Or set up SSH keys: https://docs.github.com/en/authentication/connecting-to-github-with-ssh"
                exit 0
                ;;
            *)
                info "Installing gh CLI..."
                curl -sS https://webi.sh/gh | sh

                # webi installs to ~/.local/bin, update PATH for this session
                export PATH="$HOME/.local/bin:$PATH"

                echo ""
                info "Starting authentication..."
                gh auth login

                # Use HTTPS now that gh is authenticated
                git_url="https://github.com/${repo_arg}.git"
                info "Using HTTPS (gh CLI authenticated)"
                ;;
        esac
    fi

    # Check if repo exists (requires gh CLI)
    local should_push=false
    if command -v gh >/dev/null 2>&1; then
        if ! gh repo view "$repo_arg" >/dev/null 2>&1; then
            # Repo doesn't exist - offer to create
            warn "Repository '$repo_arg' doesn't exist on GitHub"
            echo -n "Create it now? (public/private/n): "
            read -r choice

            case "$choice" in
                public)
                    gh repo create "$repo_arg" --public
                    should_push=true
                    ;;
                private)
                    gh repo create "$repo_arg" --private
                    should_push=true
                    ;;
                *)
                    error "Cancelled. Create the repo manually then run setup again."
                    ;;
            esac
        fi
    fi

    # Add remote
    git remote add origin "$git_url"
    success "Connected to $git_url"

    # If we created the repo, do initial push
    if [[ "$should_push" == "true" ]]; then
        info "Pushing initial commit..."
        git branch -M main 2>/dev/null || true

        # Create initial commit if none exists
        if ! git rev-parse HEAD >/dev/null 2>&1; then
            echo "# My Dotfiles" > README.md
            git add README.md
            git commit -m "Initial commit"
        fi

        git push -u origin main
        success "Pushed to remote"
    else
        info "Remote configured. Run 'dots push' to push your dotfiles."
    fi
}

cmd_update() {
    local install_command='curl -sSL https://raw.githubusercontent.com/DeprecatedLuar/ireallylovemydots/main/install.sh | bash'
    local force_flag=""

    # Check for --force flag
    if [[ "$1" == "--force" ]] || [[ "$1" == "-f" ]]; then
        force_flag="force"
        info "Checking for updates (bypassing cache)..."
    else
        info "Checking for updates..."
    fi

    if check_for_updates "$force_flag"; then
        echo ""
        info "Updates available!"
        echo -n "Do you want to download the latest version? (Y/n): "
        read -r choice

        case "${choice,,}" in
            n|no)
                echo ""
                info "To update manually, run:"
                echo "  $install_command"
                ;;
            *)
                echo ""
                info "Downloading and installing latest version..."
                bash -c "$install_command"
                ;;
        esac
    elif [[ $? -eq 1 ]]; then
        success "You're already up to date!"
    else
        warn "Could not check for updates (network issue?)"
        echo ""
        info "To update manually, run:"
        echo "  $install_command"
    fi
}

cmd_status() {
    check_dotfiles_repo

    for config_path in "$DOTFILES/config"/*; do
        [[ -e "$config_path" ]] || continue
        local name=$(basename "$config_path")
        local target="$HOME/.config/$name"

        if [[ -L "$target" ]] && [[ "$(readlink "$target")" == "$config_path" ]]; then
            echo -e "${GREEN}✓ $name${NC}"
        elif [[ -L "$target" ]]; then
            echo -e "${YELLOW}! $name${NC}"
        elif [[ -d "$target" ]]; then
            echo -e "${YELLOW}! $name ${YELLOW}[DIR]${NC} (directory exists, not linked)"
        elif [[ -f "$target" ]]; then
            echo -e "${YELLOW}! $name ${YELLOW}[FILE]${NC} (file exists, not linked)"
        else
            echo -e "${PURPLE}✗ $name${NC}"
        fi
    done

    for home_path in "$DOTFILES/home"/*; do
        [[ -e "$home_path" ]] || continue
        local name=$(basename "$home_path")
        local target="$HOME/$name"

        if [[ -L "$target" ]] && [[ "$(readlink "$target")" == "$home_path" ]]; then
            echo -e "${GREEN}✓ $name${NC}"
        elif [[ -L "$target" ]]; then
            echo -e "${YELLOW}! $name${NC}"
        elif [[ -d "$target" ]]; then
            echo -e "${YELLOW}! $name [DIR]${NC} (directory exists, not linked)"
        elif [[ -f "$target" ]]; then
            echo -e "${YELLOW}! $name [FILE]${NC} (file exists, not linked)"
        else
            echo -e "${PURPLE}✗ $name${NC}"
        fi
    done
}

cmd_version() {
    echo "dots $VERSION"
    notify_if_updates
}

cmd_help() {
    cat << EOF
dots - Dotfiles Manager

Usage:
  dots setup <username/repo>       Connect GitHub repo (creates if needed)
  dots detach                      Detach from GitHub (keeps local dotfiles)
  dots snatch <config> [configs]   Adopt existing config(s) into dots
  dots link <config> [configs]     Create symlink(s) from dots
  dots link -A|--all               Link all configs from dots
  dots unlink <config> [configs]   Remove symlink(s) to dots (strict)
  dots unlink -A|--all             Remove all symlinks to dots
  dots eject <config> [configs]    Remove config(s) from dots, restore to system
  dots rm <config> [configs]       Remove config(s)/link(s) (moves to trash)
  dots sync|pull                   Pull latest and check for unpushed commits
  dots push                        Push commits to remote
  dots update [--force|-f]         Update dots tool to latest version
  dots status                      Show what's linked and what's not
  dots version                     Show version information
  dots help                        Show this help

Examples:
  dots setup myuser/dotfiles       Connect to GitHub repo (auto-creates if needed)
  dots detach                      Disconnect from GitHub (work locally only)
  dots snatch nvim                 Move ~/.config/nvim to dots, create symlink
  dots snatch nvim kitty ranger    Snatch multiple configs at once
  dots snatch .gitconfig           Move ~/.gitconfig to dots, create symlink
  dots link alacritty              Link ~/.config/alacritty from dots
  dots link kitty ranger micro     Link multiple configs at once
  dots link -A                     Link all configs from dots repo
  dots unlink kitty                Remove symlink (only if points to dots)
  dots unlink -A                   Remove all symlinks pointing to dots
  dots eject nvim                  Move config out of dots, untrack from git
  dots eject kitty ranger micro    Eject multiple configs at once
  dots rm nvim                     Remove ~/.config/nvim (move to trash)
  dots update                      Check for and install updates to dots tool
  dots update --force              Force check for updates (bypass cache)

Repository: $DOTFILES
EOF
}



# ====[ UTILS ]=============================================================





# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
NC='\033[0m'

error() { echo -e "${RED}→ $1${NC}" >&2; exit 1; }
success() { echo -e "${GREEN}→ $1${NC}"; }
warn() { echo -e "${YELLOW}! $1${NC}"; }
info() { echo -e "${BLUE}→ $1${NC}"; }

check_dotfiles_repo() {
    # Create dots repo if doesn't exist
    if [[ ! -d "$DOTFILES" ]]; then
        mkdir -p "$DOTFILES"
        cd "$DOTFILES"
        git init >/dev/null 2>&1
        mkdir -p config home
    elif [[ ! -d "$DOTFILES/.git" ]]; then
        # Directory exists but not a git repo
        cd "$DOTFILES"
        git init >/dev/null 2>&1
        mkdir -p config home
    fi
}

ensure_dotfiles_structure() {
    mkdir -p "$DOTFILES/config"
    mkdir -p "$DOTFILES/home"
}

# (.nvim -> nvim)
strip_dot() {
    local raw_folder_name="$1"
    echo "${raw_folder_name#.}"
}

# Find where a config currently lives in the filesystem
# Returns: "config nvim" or "home .gitconfig" or "none"
find_in_filesystem() {
    local raw_config_name="$1"
    local config_name=$(strip_dot "$raw_config_name")

    # First: Check literal input (highest priority)
    #1 Check literal in ~/.config
    if [[ -e "$HOME/.config/$raw_config_name" ]] || [[ -L "$HOME/.config/$raw_config_name" ]]; then
        echo "config $raw_config_name"
        return
    fi

    #2 Check literal in ~/
    if [[ -e "$HOME/$raw_config_name" ]] || [[ -L "$HOME/$raw_config_name" ]]; then
        echo "home $raw_config_name"
        return
    fi

    # Second: Check variations if literal not found
    #3 Check stripped version in ~/.config (if different from raw)
    if [[ "$raw_config_name" != "$config_name" ]] && ([[ -e "$HOME/.config/$config_name" ]] || [[ -L "$HOME/.config/$config_name" ]]); then
        echo "config $config_name"
        return
    fi

    #4 Check stripped version in ~/ (if different from raw)
    if [[ "$raw_config_name" != "$config_name" ]] && ([[ -e "$HOME/$config_name" ]] || [[ -L "$HOME/$config_name" ]]); then
        echo "home $config_name"
        return
    fi

    #5 Check with dot prepended in ~/.config (if user didn't type dot)
    if [[ "$raw_config_name" == "$config_name" ]] && ([[ -e "$HOME/.config/.$config_name" ]] || [[ -L "$HOME/.config/.$config_name" ]]); then
        echo "config .$config_name"
        return
    fi

    #6 Check with dot prepended in ~/ (if user didn't type dot)
    if [[ "$raw_config_name" == "$config_name" ]] && ([[ -e "$HOME/.$config_name" ]] || [[ -L "$HOME/.$config_name" ]]); then
        echo "home .$config_name"
        return
    fi

    echo "none"
}

# Check if a config exists in dots repo
# Returns: "config nvim" or "home .gitconfig" or "none"
find_in_dotfiles() {
    local name="$1"
    local stripped=$(strip_dot "$name")

    # Check both with and without dots
    if [[ -e "$DOTFILES/config/$stripped" ]]; then
        echo "config $stripped"
        return
    fi

    if [[ -e "$DOTFILES/config/$name" ]]; then
        echo "config $name"
        return
    fi

    if [[ -e "$DOTFILES/home/$name" ]]; then
        echo "home $name"
        return
    fi

    if [[ -e "$DOTFILES/home/$stripped" ]]; then
        echo "home $stripped"
        return
    fi

    echo "none"
}

# Check if updates are available for dots tool itself
# Returns: 0 if updates available, 1 if up to date, 2 if check failed
check_for_updates() {
    local force_check="$1"
    local cache_file="$HOME/.cache/dots_update_check"
    local cache_duration=21600  # 6 hours
    local bin_file="$HOME/.local/bin/dots"

    # Create cache dir if needed
    mkdir -p "$(dirname "$cache_file")" 2>/dev/null

    # Check cache freshness (skip if force check)
    if [[ "$force_check" != "force" ]] && [[ -f "$cache_file" ]]; then
        local cache_age=$(($(date +%s) - $(stat -c %Y "$cache_file" 2>/dev/null || stat -f %m "$cache_file" 2>/dev/null || echo 0)))
        if [[ $cache_age -lt $cache_duration ]]; then
            # Return cached result
            [[ "$(cat "$cache_file")" == "updates_available" ]] && return 0 || return 1
        fi
    fi

    # Fetch latest commit hash from GitHub (silent, non-blocking)
    local remote_hash=$(curl -sS --max-time 3 "https://api.github.com/repos/DeprecatedLuar/ireallylovemydots/commits/main" 2>/dev/null | grep -m1 '"sha"' | cut -d'"' -f4 | head -c 7)

    # If fetch failed, return error (silent)
    [[ -z "$remote_hash" ]] && return 2

    # Get local install timestamp
    local local_timestamp=$(stat -c %Y "$bin_file" 2>/dev/null || stat -f %m "$bin_file" 2>/dev/null || echo 0)

    # Fetch commit date from GitHub for the latest commit
    local remote_timestamp=$(curl -sS --max-time 3 "https://api.github.com/repos/DeprecatedLuar/ireallylovemydots/commits/main" 2>/dev/null | grep '"date"' | head -1 | cut -d'"' -f4)
    local remote_epoch=$(date -d "$remote_timestamp" +%s 2>/dev/null || date -j -f "%Y-%m-%dT%H:%M:%SZ" "$remote_timestamp" +%s 2>/dev/null || echo 0)

    # Compare timestamps
    if [[ $remote_epoch -gt $local_timestamp ]]; then
        echo "updates_available" > "$cache_file"
        return 0
    else
        echo "up_to_date" > "$cache_file"
        return 1
    fi
}

# Helper to notify user if updates are available
notify_if_updates() {
    if check_for_updates 2>/dev/null; then
        echo ""
        info "A new version is available! Run 'dots update' to upgrade."
    fi
}


# ====[ PROFILE UTILITIES ]=============================================================

# Check if a config directory has profiles enabled
# Args: $1 = config name (e.g., "kitty")
# Returns: 0 if profiled, 1 if not
is_profiled_config() {
    local config_name="$1"

    # Use find_in_dotfiles() to locate config
    local result=$(find_in_dotfiles "$config_name")
    [[ "$result" == "none" ]] && return 1

    local type found_name
    read type found_name <<< "$result"

    local config_path="$DOTFILES/$type/$found_name"

    # Profiles only work for directories (not single files)
    # Future: All items in dots will be directories, enabling universal profiles
    [[ ! -d "$config_path" ]] && return 1

    [[ -f "$config_path/.profiled" ]]
}

# Get config path in dotfiles (helper for profile operations)
# Args: $1 = config name
# Outputs: full path to config dir in dots
get_config_path() {
    local config_name="$1"
    local result=$(find_in_dotfiles "$config_name")
    [[ "$result" == "none" ]] && error "'$config_name' not found in dots repo"

    local type found_name
    read type found_name <<< "$result"

    local config_path="$DOTFILES/$type/$found_name"

    # Profiles only work for directories (not single files)
    # Future: All items in dots will be directories, enabling universal profiles
    [[ ! -d "$config_path" ]] && error "'$config_name' is a file, not a directory. Profiles require directories."

    echo "$config_path"
}

# Read .profiled file
# Args: $1 = config path
# Outputs: space-separated list of tracked files
read_profiled() {
    local config_path="$1"
    local profiled="$config_path/.profiled"
    [[ ! -f "$profiled" ]] && return
    cat "$profiled" | tr '\n' ' '
}

# Write .profiled file
# Args: $1 = config path, $2+ = files to write
write_profiled() {
    local config_path="$1"
    shift
    local profiled="$config_path/.profiled"
    printf "%s\n" "$@" > "$profiled"
}

# Add to .profiled (append files)
# Args: $1 = config path, $2+ = files to add
add_to_profiled() {
    local config_path="$1"
    shift
    local profiled="$config_path/.profiled"
    for file in "$@"; do
        # Avoid duplicates
        if ! grep -Fxq "$file" "$profiled" 2>/dev/null; then
            echo "$file" >> "$profiled"
        fi
    done
}

# Remove from .profiled
# Args: $1 = config path, $2+ = files to remove
remove_from_profiled() {
    local config_path="$1"
    shift
    local profiled="$config_path/.profiled"
    [[ ! -f "$profiled" ]] && return

    local temp=$(mktemp)
    for file in "$@"; do
        grep -Fxv "$file" "$profiled" > "$temp" 2>/dev/null || true
        mv "$temp" "$profiled"
    done
}

# Get current active profile by following symlinks
# Args: $1 = config path
# Outputs: profile name (or empty if not profiled)
get_current_profile() {
    local config_path="$1"
    local profiled="$config_path/.profiled"

    [[ ! -f "$profiled" ]] && return

    # Read first tracked file and check its symlink
    local first_file=$(head -1 "$profiled")
    local link_path="$config_path/$first_file"

    if [[ -L "$link_path" ]]; then
        local target=$(readlink "$link_path")
        # Extract profile name from "profiles/NAME/file"
        echo "$target" | cut -d'/' -f2
    fi
}

# Validate profile name (check for reserved words)
# Args: $1 = profile name
# Returns: 0 if valid, 1 if invalid
validate_profile_name() {
    local name="$1"
    local reserved=("track" "init" "list" "rm" "untrack" "flatten")

    [[ -z "$name" ]] && return 1
    [[ "$name" == *"/"* ]] && return 1
    [[ "$name" == *".."* ]] && return 1

    for word in "${reserved[@]}"; do
        [[ "$name" == "$word" ]] && return 1
    done

    return 0
}

# Activate profile symlinks (remove old, create new from actual files in profile)
# Args: $1 = config path, $2 = profile name
# Note: Iterates over actual files in profile directory for robustness
activate_profile_symlinks() {
    local config_path="$1"
    local profile_name="$2"
    local profile_dir="$config_path/profiles/$profile_name"

    [[ ! -d "$profile_dir" ]] && error "Profile '$profile_name' not found"

    # Remove all existing symlinks that point to profiles/
    for item in "$config_path"/*; do
        [[ ! -L "$item" ]] && continue
        local target=$(readlink "$item")
        [[ "$target" == profiles/* ]] && rm "$item"
    done

    # Create symlinks for all files in target profile
    local linked_count=0
    for item in "$profile_dir"/*; do
        [[ ! -e "$item" ]] && continue
        local filename=$(basename "$item")
        local link_target="$config_path/$filename"

        # Check if real file exists at target (conflict)
        if [[ -e "$link_target" ]] && [[ ! -L "$link_target" ]]; then
            error "Cannot link $filename: real file exists at $link_target\nRemove manually: rm $link_target"
        fi

        # Create symlink
        ln -s "profiles/$profile_name/$filename" "$link_target"
        linked_count=$((linked_count + 1))
    done

    # Error if NO files were linked (empty profile)
    [[ $linked_count -eq 0 ]] && error "Profile '$profile_name' has no files"

    return 0
}


# ====[ PROFILE COMMANDS ]=============================================================

# Main dispatcher for profile subcommands
# Usage: dots <config> <subcommand|profile-name> [args]
cmd_profile_dispatch() {
    local config_name="$1"
    local subcommand="$2"
    shift 2

    check_dotfiles_repo

    # Get config path early (validates config exists)
    local config_path=$(get_config_path "$config_name")

    case "$subcommand" in
        track)
            profile_track "$config_path" "$@"
            ;;
        init)
            profile_init "$config_path" "$@"
            ;;
        list)
            profile_list "$config_path"
            ;;
        rm)
            profile_rm "$config_path" "$@"
            ;;
        untrack)
            profile_untrack "$config_path" "$@"
            ;;
        flatten)
            profile_flatten "$config_path"
            ;;
        "")
            # No subcommand - show help
            error "Usage: dots $config_name <subcommand>\n\nSubcommands:\n  track <files>     Mark files for profiling\n  init <name>       Create profile\n  list              List profiles\n  rm <name>         Delete profile\n  untrack <files>   Stop tracking files\n  flatten           Remove profile system"
            ;;
        *)
            # Assume it's a profile name (switch command)
            profile_switch "$config_path" "$subcommand"
            ;;
    esac
}

# Track files for profiling
# Args: $1 = config path, $2+ = files to track
profile_track() {
    local config_path="$1"
    shift
    [[ -z "$1" ]] && error "Usage: dots $(basename "$config_path") track <file> [files...]"

    local config_name=$(basename "$config_path")
    local profiled="$config_path/.profiled"

    # Validate files exist in config dir
    for file in "$@"; do
        [[ ! -e "$config_path/$file" ]] && error "File '$file' not found in $config_name/"
    done

    # Create or update .profiled
    add_to_profiled "$config_path" "$@"

    # Git commit
    cd "$DOTFILES"
    git add "$profiled" >/dev/null 2>&1
    git commit -m "profile: track $(echo $@ | tr ' ' ', ') in $config_name" >/dev/null 2>&1

    success "Tracking $(echo $@ | tr ' ' ', ') in $config_name"
}

# Initialize profile (create first one or copy from active)
# Args: $1 = config path, $2 = profile name
profile_init() {
    local config_path="$1"
    local profile_name="$2"

    [[ -z "$profile_name" ]] && error "Usage: dots $(basename "$config_path") init <profile-name>"

    local config_name=$(basename "$config_path")
    local profiled="$config_path/.profiled"

    # Validate .profiled exists
    [[ ! -f "$profiled" ]] && error "No tracked files in $config_name\nRun: dots $config_name track <files>"

    # Validate profile name
    validate_profile_name "$profile_name" || error "Invalid profile name '$profile_name'\nReserved words: track, init, list, rm, untrack, flatten\nAvoid: /, .."

    local profiles_dir="$config_path/profiles"
    local profile_dir="$profiles_dir/$profile_name"
    local files=$(read_profiled "$config_path")

    # Check if profile already exists
    [[ -d "$profile_dir" ]] && error "Profile '$profile_name' already exists"

    # Check if this is the first profile (profiles/ doesn't exist or is empty)
    local is_first_profile=false
    if [[ ! -d "$profiles_dir" ]] || [[ -z "$(ls -A "$profiles_dir" 2>/dev/null)" ]]; then
        is_first_profile=true
    fi

    mkdir -p "$profile_dir"

    if [[ "$is_first_profile" == "true" ]]; then
        # First profile - move files from root
        for file in $files; do
            local source="$config_path/$file"
            if [[ -L "$source" ]]; then
                # Symlink - dereference and copy actual content
                cp -rL "$source" "$profile_dir/"
                rm "$source"
            elif [[ -e "$source" ]]; then
                # Real file/dir - move it
                mv "$source" "$profile_dir/"
            fi
        done

        # Setup .gitignore - ignore symlinks at root (not profiles/)
        local gitignore="$config_path/.gitignore"
        {
            (cd "$profile_dir" && ls -A | sed 's|^|/|')
            echo "!profiles/"
        } > "$gitignore"

        # Activate symlinks to new profile
        activate_profile_symlinks "$config_path" "$profile_name"
    else
        # Not first profile - copy from first existing profile
        local first_existing=$(ls "$profiles_dir" | head -1)
        for file in $files; do
            local source="$profiles_dir/$first_existing/$file"
            [[ -e "$source" ]] && cp -r "$source" "$profile_dir/"
        done
        # Don't create symlinks - keep current profile active
    fi

    # Git commit
    cd "$DOTFILES"
    git add "$profile_dir" >/dev/null 2>&1
    [[ -f "$config_path/.gitignore" ]] && git add "$config_path/.gitignore" >/dev/null 2>&1
    git commit -m "profile: init $profile_name for $config_name" >/dev/null 2>&1

    success "Created profile '$profile_name' for $config_name"
}

# Switch to a profile
# Args: $1 = config path, $2 = profile name
profile_switch() {
    local config_path="$1"
    local profile_name="$2"
    local config_name=$(basename "$config_path")

    # Activate symlinks to target profile
    activate_profile_symlinks "$config_path" "$profile_name"

    success "Switched $config_name to '$profile_name'"
}

# List available profiles
# Args: $1 = config path
profile_list() {
    local config_path="$1"
    local profiles_dir="$config_path/profiles"

    [[ ! -d "$profiles_dir" ]] && error "No profiles found"

    ls "$profiles_dir"
}


# ====[ MAIN ]=============================================================

case "$1" in
    setup) cmd_setup "$2" ;;
    detach) cmd_detach ;;
    snatch) shift; cmd_snatch "$@" ;;
    link) shift; cmd_link "$@" ;;
    unlink) shift; cmd_unlink "$@" ;;
    eject) shift; cmd_eject "$@" ;;
    rm) shift; cmd_rm "$@" ;;
    sync|pull) cmd_sync ;;
    push) cmd_push ;;
    update) cmd_update "$2" ;;
    status) cmd_status ;;
    version|--version|-v) cmd_version ;;
    help|--help|-h|"") cmd_help ;;
    *)
        # Check if it's a profiled config OR a directory config that could be profiled
        if is_profiled_config "$1"; then
            cmd_profile_dispatch "$@"
        else
            # Check if it's a directory in dots (allow profile setup commands)
            _result=$(find_in_dotfiles "$1" 2>/dev/null || echo "none")
            if [[ "$_result" != "none" ]]; then
                read _type _found_name <<< "$_result"
                _config_path="$DOTFILES/$_type/$_found_name"

                # If it's a directory, allow profile commands
                if [[ -d "$_config_path" ]]; then
                    cmd_profile_dispatch "$@"
                else
                    error "Thats not a real command: $1\nTry 'dots help' for usage"
                fi
            else
                error "Thats not a real command: $1\nTry 'dots help' for usage"
            fi
        fi
        ;;
esac
